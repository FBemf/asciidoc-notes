= MATH 239: Combinatorics
:showtitle:
:page-navtitle: MATH 239: Combinatorics
:page-root: ../
:toc:
:stem:

== May 6th: Intro

The two subjects this course covers are Enumeration and Graph Theory.
We're gonna do 5 weeks of Enumeration, and 7 weeks of Graph Theory.

The typical Enumeration question is "How many elements of a set stem:[S] of
'combinatorical objects' have a given property?" We'll usually answer them by
encoding the properties of stem:[S] into an algebraic expression called the
*generating series* for stem:[S].

For example: How many ways can we choose a dozen donts if the available
flavours are chocolate, maple, lemon, and plain (and at least 12 are in
stock)?

Answer is the coefficient of stem:[x^12] in stem:[1/((1-x)^4)]

Same question but only 3 chocolate and 5 maple left.

Answer is the coefficient of stem:[x^12] in stem:[((1-x^4)(1-x^6))/((1-x)^4)].

Standard framework for enumeratiton problems: We define a set stem:[S] and a weight
function stem:[omega] that assigns each element stem:[sigma] of stem:[S] a nonnegative integer
stem:[omega(sigma)].

In Q1, stem:[S] is the setn of all collections of donutes from the 4 flavours, and
the weight functin is stem:[w(sigma) = "the number of donuts in " sigma]. Then we
ask, "how many elements of stem:[S] have a weight of 12?

Usually our set stem:[S] is a *Cartesian product* of a *disjoint union* of Cartesian
products. Recall that for sets stem:[A] and stem:[B], the Cartesian product stem:[AxxB]
is the set stem:[AxxB = {(a, b): a in A, b in B}].

The *union* stem:[AuuB] is stem:[AuuB = {x: x in A " or " x in B}], and the *intersection*
stem:[AnnB] is stem:[AnnB = {x: x in A " and " x in B}]. The set stem:[AuuB] is a
*disjoint union* if stem:[AnnB = O/] when stem:[A] and stem:[B] are finite sets, the *size* of stem:[AxxB, AuuB, " etc"] (denoted by stem:[|AuuB|, |AxxB|, " etc"]) is given by
stem:[|AxxB| = |A| |B|] and stem:[|AuuB = |A| + |B| - |AnnB|].

So if stem:[AuuB] is a *disjoint* union we set stem:[|AuuB| = |A| + |B|].

The kth *Cartesian power* of a set stem:[A] is the set of all ordered k-tubples of elements
of stem:[A].

[stem]
++++
A^k = {(a_1, a_2, ..., a_k): a_i in A " for each " i}
++++

If stem:[A] is a finite set then stem:[|A^k| = |A|^k].

Suppose the donut shop has 3 chocolate, 5 maple, 19 lemon, and 17 plain donuts.
Describe all possible collections of donutes (of any size) as a Cartesian product.

[stem]
++++
{0,1,2,3} xx {0,1,2,3,4,5} xx {0,1,2, ... ,19} xx {0,1,2, ... ,17}
++++

Ok, fix a positive integer stem:[m]. Let stem:[S] be the subset of all subsets of
stem:[{1, 2, ..., m}].
Let the weight function stem:[omega] be defined on stem:[S] by stem:[omega(sigma)=|omega|].

How many elements of stem:[S] have weight stem:[k]? (for any stem:[k])

Answer is stem:[((m), (k))]. I think. Almost missed this bit.


== May 8th

=== n choose k

The number stem:[B(m, k)] of k-subsets of stem:[{1, 2, ..., m}]
is stem:[(m(m-1)...(m-k+1))/(k!)].

Proof: Let stem:[L] be the set of all ordered k-tuples of distinct elements of
stem:[{1, 2, ..., m}]. Then stem:[|L| = m(m-1)(m-2)...(m-k+1)].

We could also count stem:[|L|] by listing all stem:[B(m, k)] k-subsets of
stem:[{1, 2, ..., m}] and ordering each in all stem:[k!] possible ways.

So stem:[|L| = B(m, k)k!].
We use the notation stem:[((m), (k)) i= (m(m-1)...(m-k+1))/(k!)]

[NOTE]
====
This expression is defined for all stem:[K >= 0 in ZZ] and all stem:[m in RR]
(or even all stem:[m in CC]). When stem:[m >= k] is an integer:

- stem:[((m), (k)) = (m!)/((m-k)!k!)]
- stem:[((m), (k)) = ((m), (m-k))]
- stem:[((m), (k)) = 0]
- stem:[0!] is the *empty product*, which is 1. So stem:[((m), (0)) = 1]
====

=== Bijections

A *bijection* (or 1-to-1 correspondence) from a set stem:[S] to a set stem:[T] is a functon
stem:[f: S -> T] that is:

- 1-1, which means stem:[f(s_1) = f(s_2) -> s_1 = s_2] (injection)
- onto,  which means stem:[AA t in T EE s in S f(s) = t] (surjection)

If stem:[f: S -> T] is a bijection, then stem:[|S| = |T|].

[NOTE, caption="example"]
====
There is a bijection stem:[f] from stem:[S =] the set of all subsets of stem:[{1, ..., m}]
to stem:[T = {0, 1}^m] (where exponentiation means repeated Cartesian product). Proof
is not complex.
====

.Lemma
****
If stem:[f: S -> T] has an inverse, then it's a bijection.

Proof: Let stem:[g: T -> S] be the inverse of f.

Check f is 1-1: if stem:[f(s_1) = f(s_2)], then
stem:[g(f(s_1)) = g(f(s_2))], so stem:[s_1 = s_2]. Hence f is 1-1.

Check f is onto: Let stem:[t in T]. Let stem:[s = g(t)]. Then
stem:[f(s) = f(g(t))] = t]. Hence stem:[f] is onto.

Therefore stem:[f] is a bijection. stem:[square].

The converse (that stem:[f] being a bijection makes it have an inverse]
also holds.
****

.Corollary
****
[stem]
++++
sum _k=0 ^m ((m), (k)) = 2^m
++++

We are writing the size of the set of all subsets of stem:[{1, ..., m}] in
two ways.

This is a *combinatorial proof*, where we count the members of a set in two
different ways and get two different expressions of its size, which must then
be equal
****


== May 10th

=== Binomial Theorem:

[stem]
++++
AA m in ZZ_(>=0) AA x (1+x)^m = sum _k(k=0) ^m (((m), (k)) x^k

"Proof: " (1+x)^m = (1+x)(1+x)...(1+x) = (x^0 + x^1) (x^0 + x^1) ... (x^0 + x^1)

= x^(0+0+0+...) + x^(1+0+0+...) + ... " ("2^n" terms"
++++

Our bijection from last class, which mapped the subsets of a set with size m to
stem:[{0, 1}^m]] applies here, since the exponent terms fit that pattern.

The number of terms in which the exponent adds up to exactly k is the number
of elements of T with exactly k 1s. By our bijection, we know that the number
of k-subsets of stem:[{1, ..., m}]. It's stem:[((m), (k))]. Thus:

[stem]
++++
(1+x)^m = sum _(k=0) ^m ((m), (k)) x^k
++++

.Corollary
****
[stem]
++++
sum _(k=0) ^m ((m), (k)) = (1+1)^m = 2^m
++++
****

This is a great demonstration of the idea of a combinatorical proof.
The idea is to express numbers in terms of the size of a set, which
we describe in two different ways.

Often binomial coefficients are involved.

For instance: give a combinatorial prove that stem:[((n), (k)) = ((n-1), (k)) + ((n-1), (k-1))].

Proof: we take stem:[((n),(k))] as the size of S,
which is the set of all k-subsets of stem:[{1, 2, ..., n}].

We can write stem:[S = S_0uuS_1], where stem:[S_0nnS_1 = O/] where stem:[S_0 =] the
set of all k-subsets of {1, 2, ..., n} that do NOT contain the last element n.
stem:[S_1 = ] those that do.

Then stem:[S_0] is the set of k-subsets of stem:[{1, 2, ..., n-1}]. Therefore
stem:[|S_0| = ((n-1), (k))].

Then there is a bijection from stem:[S_1] to the set of all (k-1)-subsets of
stem:[{1, 2, ..., n-1}] obtained by removing the element n. Thus,
stem:[|S_1| = ((n-1),(k-1))]. Hence:

[stem]
++++
((n),(k)) = |S| = |S_0| + |S_1| = ((n-1),(k)) + ((n-1),(k-1))
++++

Theorem: For stem:[n, k in ZZ_(>=0)], we have
stem:[((n+k),(n)) = sum _(i-0) ^k ((n+i-1),(n-1))].

Proof: Let stem:[S] be the set of of all n-subsets of stem:[{1, 2, ..., n+k}].
Then stem:[|S| = ((n+k),(n))].

Let stem:[S_i] be the set of all n-subsets of stem:[{1, ..., n+k}] whose largest
element is stem:[n+i]. Do this for stem:[0<=i<=k]. Then stem:[S=S_0uuS_1uu...uuS_k] is
a disjoint union. For each i, each element of stem:[S_i] is of the form
stem:[sigma =Auu{n+1}], where A is an (n-1)-subset of stem:[{1, 2, ..., n+i-1}],
since stem:[n+i] is the largest element in stem:[sigma].

Conversely, every (n-1)-subset A of stem:[{1, 2, ..., n+1-1}] together with stem:[n_1]
gives an element of stem:[S_i]. So we get a bijection from stem:[S_i] toi the set of
(n-1)-subsets of stem:[{1, 2, ..., n+i-1}] obtained by removing stem:[n+i].

Hence stem:[|S_i| = ((n+i-1),(n-1))]. Thus,

[stem]
++++
((n_k),(n)) = |S| = sum _(i=0) ^k |S_i| = sum _(i=0) ^k ((n+i-1),(n-1))

square
++++

For a set S, a *weight function* on S is a function stem:[w: S -> ZZ_(>=0)] such that
for each stem:[n in ZZ_(>=0)], the number of elements stem:[sigma in S] with
stem:[w(sigma) = n] is finite.


== May 13th

=== Weight functions and indeterminates

A *weight function* on a set stem:[S] is a function stem:[w: S -> ZZ_(>=0)] such that,
for every stem:[n >= 0], stem:[{sigma in S: w(sigma)=n}] is finite.

Let stem:[S] be a set and let stem:[w] be a weight function on stem:[S]. The *generating
series* for stem:[S] with respect to stem:[w], in the indeterminate stem:[x], is

[stem]
++++
Psi_s(x) = sum _(sigma in S) x^(w(sigma)).
++++

We can collect the like terms and write

[stem]
++++
Psi_s(x) = sum _(k>=0} a_k x^k
++++

where stem:[a_k] is the number of elements of stem:[S] of weight stem:[k].

[NOTE, caption="Example"]
====
Let stem:[S =] the set of all subsets of stem:[{1, 2, ..., m}].
Let stem:[w(sigma) = |sigma|]. Then

[stem]
++++
Psi_s(x) = sum _(k>=0) ((m),(k)) x^k = sum _(k = 0) ^m ((m),(k)) x^k = (1+x)^m
++++
====

[NOTE, caption="Example"]
====
[stem]
++++
S = ZZ_(>=0)

w(sigma) = sigma

Psi_s(x) = sum_(i>=0) x^i
++++
====

stem:[x] is an *indeterminate*. Don't think of it as something that you substitute
for a number; doing that with a generating series just gets you noise (unless stem:[S]
is finite).

An indeterminate is a symbol that satisfies stem:[x^0 = 1, x^a+x^b = x^(a+b),
(x^a)^b=x^(ab)].

If stem:[S] is infinite, stem:[Psi_s(x)] is an infinite sum. This will be a *formal power series*
(more on that later).

.Theorem
****
Let stem:[S] be a finite set with weight funtion stem:[w] (so stem:[Psi_s(x)] is a polynomial).
Then

. stem:[Psi_s'(1) = |S|]
. stem:[Psi_s'(1)] is the total weight of all elements in stem:[S].

Proof:

[stem]
++++
Psi_x(s) = sum _(sigma in S) x^(w(sigma))

Psi_s(1) = sum _(sigma in S) 1^(w(sigma)) = |S|

Psi_s'(x) = sum _(sigma in S) w(sigma) x^(w(sigma)-1)

Psi_s'(x) = sum _(sigma in S) w(sigma)
++++
****

[NOTE, caption="Example"]
====
stem:[S] is the set consisting of 5 nickels, 12 dimes and 3 quarters. Let stem:[w(sigma)=] the 
value of stem:[sigma], in cents.

[stem]
++++
Psi_s(x) = 5x^5 + 12x^10 + 3x^25

Psi_s'(x) = 25x^4 + 120x^9 + 75x^24

Psi_s(1) = 5 + 12 + 3 = 20

Psi_s'(1) = 25 + 120 + 75 = 220
++++
====

=== Formal power series

.Definiton
****
A *formal power series* over the rational numbers in the indeterminate stem:[x] is a formal
expression of the following type:

[stem]
++++
A(x) = sum _(i>=0) a_i x^i, a_i in QQ
++++

You can do several kinds of arithmetic with them.

* Addition: for stem:[A(x) = sum _(i>=0) a_i x^i]l and
stem:[B(x) = sum _(i>=0) b_i x^i] we define
+
[stem]
++++
A(x)+B(x) = sum _(i>=0)(a_i+b_i)x^i
++++
+
Subtraction follows trivially.

* Multiplication generalizes polynomial multiplication:
+
[stem]
++++
A(x)B(x) = sum_(i>=0) (sum _(j=0) ^i a_j b_(i-j))x^i
++++
+
Note that stem:[A(x)B(x) = B(x)A(x)].

* Equality: stem:[A(x) = B(x)] if and only if stem:[a_i=b_i] across all stem:[i>=0].

* Coefficients: stem:[a_i] is called the *coefficient* of stem:[x^i] in stem:[A(x)].
We write stem:[a_i=\[x^i\]A(x)].

* Inverse: We say that stem:[B(x)] is the multiplicative inverse of stem:[A(x)] if
stem:[A(x)B(x) = 1 = 1+0x+0x^2+...].
****
